{"ast":null,"code":"var _jsxFileName = \"/Users/lakshmanmandapati/Downloads/final/frontend/src/contexts/SocketContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport io from 'socket.io-client';\nimport { useAuth } from './AuthContext'; // It's common for SocketContext to depend on AuthContext\n\n// --- Define the shape of the context value ---\n// This tells TypeScript what data and functions will be available.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// --- Create the Context ---\n// This creates the context object that components will subscribe to.\nconst SocketContext = /*#__PURE__*/createContext(undefined);\n\n// --- Create a Custom Hook ---\n// This is a helper hook that makes it easy for other components to get the socket info.\nexport const useSocket = () => {\n  _s();\n  const context = useContext(SocketContext);\n  if (context === undefined) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n\n// --- Create the Provider Component ---\n// This is the main component that will wrap your app (or parts of it).\n// It manages the actual socket connection.\n_s(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const SocketProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth(); // Get user from AuthContext to manage the connection\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  useEffect(() => {\n    // We only want to establish a socket connection if the user is logged in\n    // and that user object actually contains a token.\n    if (user && 'token' in user && user.token) {\n      // IMPORTANT: Make sure this URL points to your backend server.\n      // It should match the proxy in your package.json if you're using one.\n      const newSocket = io('http://localhost:5000', {\n        // Sending the auth token with the connection is a common pattern for authentication.\n        // We use `(user as any)` here to bypass the TypeScript error, as our check above\n        // already confirms the token exists. The ideal fix is in the AuthContext type definitions.\n        auth: {\n          token: user.token\n        }\n      });\n      setSocket(newSocket);\n\n      // --- Set up event listeners ---\n      newSocket.on('connect', () => {\n        setIsConnected(true);\n        console.log('Socket connected successfully:', newSocket.id);\n      });\n      newSocket.on('disconnect', () => {\n        setIsConnected(false);\n        console.log('Socket disconnected.');\n      });\n\n      // --- Clean up the connection ---\n      // This function will be called when the component unmounts or when the user changes.\n      // It's crucial for preventing memory leaks.\n      return () => {\n        newSocket.disconnect();\n      };\n    }\n  }, [user]); // This effect re-runs whenever the user object changes.\n\n  // The value that will be provided to all consuming components.\n  const value = {\n    socket,\n    isConnected\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 75,\n    columnNumber: 5\n  }, this);\n};\n_s2(SocketProvider, \"Lq2+8CNb/Js5HfPWSeCdGXPosD4=\", false, function () {\n  return [useAuth];\n});\n_c = SocketProvider;\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","io","useAuth","jsxDEV","_jsxDEV","SocketContext","undefined","useSocket","_s","context","Error","SocketProvider","children","_s2","user","socket","setSocket","isConnected","setIsConnected","token","newSocket","auth","on","console","log","id","disconnect","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/lakshmanmandapati/Downloads/final/frontend/src/contexts/SocketContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\r\nimport io, { Socket } from 'socket.io-client';\r\nimport { useAuth } from './AuthContext'; // It's common for SocketContext to depend on AuthContext\r\n\r\n// --- Define the shape of the context value ---\r\n// This tells TypeScript what data and functions will be available.\r\ninterface SocketContextType {\r\n  socket: Socket | null;\r\n  isConnected: boolean;\r\n}\r\n\r\n// --- Create the Context ---\r\n// This creates the context object that components will subscribe to.\r\nconst SocketContext = createContext<SocketContextType | undefined>(undefined);\r\n\r\n// --- Create a Custom Hook ---\r\n// This is a helper hook that makes it easy for other components to get the socket info.\r\nexport const useSocket = () => {\r\n  const context = useContext(SocketContext);\r\n  if (context === undefined) {\r\n    throw new Error('useSocket must be used within a SocketProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// --- Create the Provider Component ---\r\n// This is the main component that will wrap your app (or parts of it).\r\n// It manages the actual socket connection.\r\nexport const SocketProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\r\n  const { user } = useAuth(); // Get user from AuthContext to manage the connection\r\n  const [socket, setSocket] = useState<Socket | null>(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n\r\n  useEffect(() => {\r\n    // We only want to establish a socket connection if the user is logged in\r\n    // and that user object actually contains a token.\r\n    if (user && 'token' in user && (user as any).token) {\r\n      // IMPORTANT: Make sure this URL points to your backend server.\r\n      // It should match the proxy in your package.json if you're using one.\r\n      const newSocket = io('http://localhost:5000', {\r\n        // Sending the auth token with the connection is a common pattern for authentication.\r\n        // We use `(user as any)` here to bypass the TypeScript error, as our check above\r\n        // already confirms the token exists. The ideal fix is in the AuthContext type definitions.\r\n        auth: {\r\n          token: (user as any).token\r\n        }\r\n      });\r\n\r\n      setSocket(newSocket);\r\n\r\n      // --- Set up event listeners ---\r\n      newSocket.on('connect', () => {\r\n        setIsConnected(true);\r\n        console.log('Socket connected successfully:', newSocket.id);\r\n      });\r\n\r\n      newSocket.on('disconnect', () => {\r\n        setIsConnected(false);\r\n        console.log('Socket disconnected.');\r\n      });\r\n\r\n      // --- Clean up the connection ---\r\n      // This function will be called when the component unmounts or when the user changes.\r\n      // It's crucial for preventing memory leaks.\r\n      return () => {\r\n        newSocket.disconnect();\r\n      };\r\n    }\r\n  }, [user]); // This effect re-runs whenever the user object changes.\r\n\r\n  // The value that will be provided to all consuming components.\r\n  const value = { socket, isConnected };\r\n\r\n  return (\r\n    <SocketContext.Provider value={value}>\r\n      {children}\r\n    </SocketContext.Provider>\r\n  );\r\n};\r\n"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,SAAS,EAAEC,QAAQ,QAAmB,OAAO;AACxF,OAAOC,EAAE,MAAkB,kBAAkB;AAC7C,SAASC,OAAO,QAAQ,eAAe,CAAC,CAAC;;AAEzC;AACA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAMA;AACA;AACA,MAAMC,aAAa,gBAAGR,aAAa,CAAgCS,SAAS,CAAC;;AAE7E;AACA;AACA,OAAO,MAAMC,SAAS,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC7B,MAAMC,OAAO,GAAGX,UAAU,CAACO,aAAa,CAAC;EACzC,IAAII,OAAO,KAAKH,SAAS,EAAE;IACzB,MAAM,IAAII,KAAK,CAAC,gDAAgD,CAAC;EACnE;EACA,OAAOD,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AAAAD,EAAA,CAVaD,SAAS;AAWtB,OAAO,MAAMI,cAAiD,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,GAAA;EACjF,MAAM;IAAEC;EAAK,CAAC,GAAGZ,OAAO,CAAC,CAAC,CAAC,CAAC;EAC5B,MAAM,CAACa,MAAM,EAAEC,SAAS,CAAC,GAAGhB,QAAQ,CAAgB,IAAI,CAAC;EACzD,MAAM,CAACiB,WAAW,EAAEC,cAAc,CAAC,GAAGlB,QAAQ,CAAC,KAAK,CAAC;EAErDD,SAAS,CAAC,MAAM;IACd;IACA;IACA,IAAIe,IAAI,IAAI,OAAO,IAAIA,IAAI,IAAKA,IAAI,CAASK,KAAK,EAAE;MAClD;MACA;MACA,MAAMC,SAAS,GAAGnB,EAAE,CAAC,uBAAuB,EAAE;QAC5C;QACA;QACA;QACAoB,IAAI,EAAE;UACJF,KAAK,EAAGL,IAAI,CAASK;QACvB;MACF,CAAC,CAAC;MAEFH,SAAS,CAACI,SAAS,CAAC;;MAEpB;MACAA,SAAS,CAACE,EAAE,CAAC,SAAS,EAAE,MAAM;QAC5BJ,cAAc,CAAC,IAAI,CAAC;QACpBK,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEJ,SAAS,CAACK,EAAE,CAAC;MAC7D,CAAC,CAAC;MAEFL,SAAS,CAACE,EAAE,CAAC,YAAY,EAAE,MAAM;QAC/BJ,cAAc,CAAC,KAAK,CAAC;QACrBK,OAAO,CAACC,GAAG,CAAC,sBAAsB,CAAC;MACrC,CAAC,CAAC;;MAEF;MACA;MACA;MACA,OAAO,MAAM;QACXJ,SAAS,CAACM,UAAU,CAAC,CAAC;MACxB,CAAC;IACH;EACF,CAAC,EAAE,CAACZ,IAAI,CAAC,CAAC,CAAC,CAAC;;EAEZ;EACA,MAAMa,KAAK,GAAG;IAAEZ,MAAM;IAAEE;EAAY,CAAC;EAErC,oBACEb,OAAA,CAACC,aAAa,CAACuB,QAAQ;IAACD,KAAK,EAAEA,KAAM;IAAAf,QAAA,EAClCA;EAAQ;IAAAiB,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACa,CAAC;AAE7B,CAAC;AAACnB,GAAA,CAlDWF,cAAiD;EAAA,QAC3CT,OAAO;AAAA;AAAA+B,EAAA,GADbtB,cAAiD;AAAA,IAAAsB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}